---
alwaysApply: true
---
## Query Helper Pattern

### Creating Query Helpers in `db/queries/`

**THIS IS THE ONLY PLACE WHERE DATABASE QUERIES ARE ALLOWED.**

All database queries must be defined as helper functions in the `db/queries/` directory:

```typescript
// db/queries/decks.ts
import { db } from '@/db';
import { decksTable, cardsTable } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';

/**
 * Get all decks for a specific user
 */
export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

/**
 * Get a single deck by ID for a specific user
 */
export async function getUserDeck(userId: string, deckId: number) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    );
  
  return deck ?? null;
}

/**
 * Get a deck with its cards
 */
export async function getUserDeckWithCards(userId: string, deckId: number) {
  const deck = await getUserDeck(userId, deckId);
  
  if (!deck) {
    return null;
  }
  
  const cards = await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(desc(cardsTable.createdAt));
  
  return { ...deck, cards };
}

/**
 * Create a new deck for a user
 */
export async function createDeck(userId: string, name: string, description?: string) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning();
  
  return newDeck;
}

/**
 * Update a deck (with ownership verification)
 */
export async function updateDeck(
  userId: string,
  deckId: number,
  data: { name: string; description?: string }
) {
  const [updated] = await db
    .update(decksTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    )
    .returning();
  
  return updated ?? null;
}

/**
 * Delete a deck (with ownership verification)
 */
export async function deleteDeck(userId: string, deckId: number) {
  const [deleted] = await db
    .delete(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    )
    .returning();
  
  return deleted ?? null;
}
```

## Data Retrieval Pattern

### ‚úÖ CORRECT: Server Components Using Query Helpers

```typescript
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import { getUserDecks } from '@/db/queries/decks';

// Server Component - fetches data using query helpers
export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/');
  }
  
  // ‚úÖ Use query helper from db/queries/
  const decks = await getUserDecks(userId);
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ‚ùå FORBIDDEN: Direct Database Queries in Components

```typescript
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

// ‚ùå DO NOT write queries directly in components
export default async function DecksPage() {
  const { userId } = await auth();
  
  // ‚ùå FORBIDDEN - Query logic belongs in db/queries/
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return <div>...</div>;
}
```

### ‚ùå FORBIDDEN: Client-Side Data Fetching

```typescript
'use client';

import { useEffect, useState } from 'react';

// ‚ùå DO NOT fetch data in client components
export function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ‚ùå DO NOT use useEffect to fetch data
    fetch('/api/decks')
      .then(res => res.json())
      .then(setDecks);
  }, []);
  
  return <div>...</div>;
}
```

```typescript
'use client';

// ‚ùå DO NOT use React Query, SWR, or other client-side data fetching
export function DecksPage() {
  const { data } = useQuery('/api/decks'); // ‚ùå FORBIDDEN
  return <div>...</div>;
}
```

## Data Mutation Pattern

### Zod Schema Definition

Create validation schemas in a dedicated file or co-located with server actions:

```typescript
// lib/validations.ts or actions/deck-actions.ts
import { z } from 'zod';

export const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const updateDeckSchema = z.object({
  id: z.number().positive(),
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().max(1000, 'Description too long').optional(),
});

export const deleteDeckSchema = z.object({
  id: z.number().positive(),
});

export const createCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string().min(1, 'Front text is required'),
  back: z.string().min(1, 'Back text is required'),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof createDeckSchema>;
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;
export type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;
export type CreateCardInput = z.infer<typeof createCardSchema>;
```

### ‚úÖ CORRECT: Server Actions Using Query Helpers

```typescript
'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { createDeckSchema, type CreateDeckInput } from '@/lib/validations';
import { createDeck as createDeckQuery, updateDeck as updateDeckQuery, deleteDeck as deleteDeckQuery } from '@/db/queries/decks';

// ‚úÖ Typed parameter (not FormData)
export async function createDeckAction(input: CreateDeckInput) {
  // ‚úÖ Validate with Zod
  const validated = createDeckSchema.safeParse(input);
  
  if (!validated.success) {
    return {
      success: false,
      error: validated.error.flatten().fieldErrors,
    };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const newDeck = await createDeckQuery(
      userId,
      validated.data.name,
      validated.data.description
    );
    
    // ‚úÖ Revalidate to update UI
    revalidatePath('/decks');
    
    return { success: true, data: newDeck };
  } catch (error) {
    console.error('Create deck error:', error);
    return { success: false, error: 'Failed to create deck' };
  }
}

export async function updateDeckAction(input: UpdateDeckInput) {
  // ‚úÖ Validate
  const validated = updateDeckSchema.safeParse(input);
  if (!validated.success) {
    return {
      success: false,
      error: validated.error.flatten().fieldErrors,
    };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const updated = await updateDeckQuery(userId, validated.data.id, {
      name: validated.data.name,
      description: validated.data.description,
    });
    
    if (!updated) {
      return { success: false, error: 'Deck not found or unauthorized' };
    }
    
    revalidatePath('/decks');
    revalidatePath(`/decks/${updated.id}`);
    
    return { success: true, data: updated };
  } catch (error) {
    console.error('Update deck error:', error);
    return { success: false, error: 'Failed to update deck' };
  }
}

export async function deleteDeckAction(input: DeleteDeckInput) {
  // ‚úÖ Validate
  const validated = deleteDeckSchema.safeParse(input);
  if (!validated.success) {
    return { success: false, error: 'Invalid input' };
  }
  
  // ‚úÖ Authenticate
  const { userId } = await auth();
  if (!userId) {
    return { success: false, error: 'Unauthorized' };
  }
  
  try {
    // ‚úÖ Use query helper from db/queries/
    const deleted = await deleteDeckQuery(userId, validated.data.id);
    
    if (!deleted) {
      return { success: false, error: 'Deck not found or unauthorized' };
    }
    
    revalidatePath('/decks');
    
    return { success: true, data: deleted };
  } catch (error) {
    console.error('Delete deck error:', error);
    return { success: false, error: 'Failed to delete deck' };
  }
}
```

### ‚ùå FORBIDDEN: Direct Database Queries in Server Actions

```typescript
'use server';

import { db } from '@/db';
import { decksTable } from '@/db/schema';

// ‚ùå DO NOT write queries directly in server actions
export async function createDeckAction(input: CreateDeckInput) {
  const { userId } = await auth();
  
  // ‚ùå FORBIDDEN - Query logic belongs in db/queries/
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: input.name,
      description: input.description,
    })
    .returning();
  
  return { success: true, data: newDeck };
}
```

### ‚ùå FORBIDDEN: Anti-Patterns - NEVER DO THESE

**1. Direct Database Queries (CRITICAL VIOLATION)**
```typescript
// ‚ùå FORBIDDEN - Writing queries outside db/queries/
import { db } from '@/db'; // ‚ùå If you see this outside db/queries/, it's WRONG

export async function DecksPage() {
  // ‚ùå FORBIDDEN - Any db.select/insert/update/delete outside db/queries/
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId)); // ‚ùå ARCHITECTURAL VIOLATION
}

// ‚úÖ CORRECT - Use query helper
import { getUserDecks } from '@/db/queries/decks';

export async function DecksPage() {
  const decks = await getUserDecks(userId); // ‚úÖ CORRECT
}
```

**2. Importing Database Client Outside db/queries/ (CRITICAL VIOLATION)**
```typescript
// ‚ùå FORBIDDEN - Importing db outside db/queries/
import { db } from '@/db'; // ‚ùå WRONG - This import should ONLY be in db/queries/*.ts

// ‚ùå FORBIDDEN - Importing table schemas outside db/queries/
import { decksTable, cardsTable } from '@/db/schema'; // ‚ùå WRONG - Only in db/queries/*.ts

// ‚úÖ CORRECT - Only import query helpers
import { getUserDecks, createDeck } from '@/db/queries/decks'; // ‚úÖ CORRECT
```

**3. Using FormData Type**
```typescript
// ‚ùå DO NOT use FormData as the parameter type
export async function createDeckAction(formData: FormData) {
  const name = formData.get('name');
  // ...
}

// ‚úÖ CORRECT - Use typed objects
export async function createDeckAction(input: CreateDeckInput) {
  const validated = createDeckSchema.safeParse(input);
  // ...
}
```

**4. No Validation**
```typescript
// ‚ùå DO NOT skip Zod validation
export async function createDeckAction(input: CreateDeckInput) {
  // Missing: const validated = createDeckSchema.safeParse(input);
  
  const deck = await createDeckQuery(userId, input.name); // ‚ùå Using unvalidated input
}

// ‚úÖ CORRECT - Always validate
export async function createDeckAction(input: CreateDeckInput) {
  const validated = createDeckSchema.safeParse(input); // ‚úÖ CORRECT
  if (!validated.success) {
    return { success: false, error: validated.error.flatten().fieldErrors };
  }
  // ...
}
```

**5. Client-Side Database Access (CRITICAL VIOLATION)**
```typescript
'use client';

import { db } from '@/db'; // ‚ùå FORBIDDEN - Cannot import db in client components

// ‚ùå DO NOT perform database operations in client components
export function CreateDeckForm() {
  const handleSubmit = async () => {
    await db.insert(decksTable).values({...}); // ‚ùå ARCHITECTURAL VIOLATION
  };
}

// ‚úÖ CORRECT - Call server actions
import { createDeckAction } from '@/actions/deck-actions';

export function CreateDeckForm() {
  const handleSubmit = async () => {
    await createDeckAction({ name: 'My Deck' }); // ‚úÖ CORRECT
  };
}
```

**6. API Routes for Mutations**
```typescript
// app/api/decks/route.ts
// ‚ùå DO NOT use API routes for mutations - use Server Actions instead
export async function POST(request: Request) {
  const body = await request.json();
  
  // ‚ùå Even worse - direct database query in API route
  await db.insert(decksTable).values(body);
  // ...
}

// ‚úÖ CORRECT - Use Server Actions for mutations
// actions/deck-actions.ts
'use server';

export async function createDeckAction(input: CreateDeckInput) {
  // Validation, authentication, then call query helper
  const newDeck = await createDeck(userId, validated.data.name);
  return { success: true, data: newDeck };
}
```

**7. Mixing Query Logic with Business Logic**
```typescript
// ‚ùå FORBIDDEN - Query logic mixed with component logic
export async function DecksPage() {
  const { userId } = await auth();
  
  // ‚ùå WRONG - Complex query with joins, filters, ordering in component
  const decks = await db
    .select({
      id: decksTable.id,
      name: decksTable.name,
      cardCount: sql<number>`count(${cardsTable.id})`,
    })
    .from(decksTable)
    .leftJoin(cardsTable, eq(decksTable.id, cardsTable.deckId))
    .where(eq(decksTable.userId, userId))
    .groupBy(decksTable.id)
    .orderBy(desc(decksTable.createdAt));
  
  return <div>...</div>;
}

// ‚úÖ CORRECT - Query logic in db/queries/
// db/queries/decks.ts
export async function getUserDecksWithCardCount(userId: string) {
  return await db
    .select({
      id: decksTable.id,
      name: decksTable.name,
      cardCount: sql<number>`count(${cardsTable.id})`,
    })
    .from(decksTable)
    .leftJoin(cardsTable, eq(decksTable.id, cardsTable.deckId))
    .where(eq(decksTable.userId, userId))
    .groupBy(decksTable.id)
    .orderBy(desc(decksTable.createdAt));
}

// Component
import { getUserDecksWithCardCount } from '@/db/queries/decks';

export async function DecksPage() {
  const { userId } = await auth();
  const decks = await getUserDecksWithCardCount(userId); // ‚úÖ CORRECT
  return <div>...</div>;
}
```

## Client Component Integration

### Using Server Actions in Client Components

```typescript
'use client';

import { useState } from 'react';
import { createDeckAction, type CreateDeckInput } from '@/actions/deck-actions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export function CreateDeckForm() {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    
    // ‚úÖ Call server action with typed data
    const input: CreateDeckInput = { name, description };
    const result = await createDeckAction(input);
    
    if (result.success) {
      setName('');
      setDescription('');
      // Optionally show success message or redirect
    } else {
      setError(typeof result.error === 'string' ? result.error : 'Failed to create deck');
    }
    
    setIsLoading(false);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <Input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Deck name"
        disabled={isLoading}
      />
      <Input
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Description (optional)"
        disabled={isLoading}
      />
      {error && <p className="text-destructive">{error}</p>}
      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Deck'}
      </Button>
    </form>
  );
}
```

### Using useTransition for Optimistic Updates

```typescript
'use client';

import { useTransition } from 'react';
import { deleteDeckAction } from '@/actions/deck-actions';
import { Button } from '@/components/ui/button';

export function DeleteDeckButton({ deckId }: { deckId: number }) {
  const [isPending, startTransition] = useTransition();
  
  const handleDelete = () => {
    if (!confirm('Are you sure?')) return;
    
    startTransition(async () => {
      const result = await deleteDeckAction({ id: deckId });
      if (!result.success) {
        alert(result.error);
      }
    });
  };
  
  return (
    <Button
      variant="destructive"
      onClick={handleDelete}
      disabled={isPending}
    >
      {isPending ? 'Deleting...' : 'Delete'}
    </Button>
  );
}
```

## Validation Patterns

### Complex Validation

```typescript
import { z } from 'zod';

// Custom refinements
export const createCardSchema = z.object({
  deckId: z.number().positive(),
  front: z.string()
    .min(1, 'Front text is required')
    .max(1000, 'Front text too long'),
  back: z.string()
    .min(1, 'Back text is required')
    .max(1000, 'Back text too long'),
}).refine(
  (data) => data.front !== data.back,
  { message: 'Front and back cannot be identical', path: ['back'] }
);

// Optional fields with defaults
export const updateUserPreferencesSchema = z.object({
  cardsPerSession: z.number().int().min(1).max(100).default(10),
  showHints: z.boolean().default(true),
  theme: z.enum(['light', 'dark', 'system']).default('system'),
});

// Nested objects
export const bulkCreateCardsSchema = z.object({
  deckId: z.number().positive(),
  cards: z.array(
    z.object({
      front: z.string().min(1),
      back: z.string().min(1),
    })
  ).min(1, 'At least one card is required'),
});
```

### Handling Validation Errors in UI

```typescript
'use client';

import { useState } from 'react';
import { createCardAction, type CreateCardInput } from '@/actions/card-actions';
import { ZodError } from 'zod';

type FieldErrors = {
  [K in keyof CreateCardInput]?: string[];
};

export function CreateCardForm({ deckId }: { deckId: number }) {
  const [front, setFront] = useState('');
  const [back, setBack] = useState('');
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setFieldErrors({});
    
    const result = await createCardAction({ deckId, front, back });
    
    if (!result.success) {
      if (typeof result.error === 'object') {
        // Zod field errors
        setFieldErrors(result.error as FieldErrors);
      }
    } else {
      setFront('');
      setBack('');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <Input value={front} onChange={(e) => setFront(e.target.value)} />
        {fieldErrors.front && (
          <p className="text-destructive text-sm">{fieldErrors.front[0]}</p>
        )}
      </div>
      <div>
        <Input value={back} onChange={(e) => setBack(e.target.value)} />
        {fieldErrors.back && (
          <p className="text-destructive text-sm">{fieldErrors.back[0]}</p>
        )}
      </div>
      <Button type="submit">Create Card</Button>
    </form>
  );
}
```

## File Structure

Recommended organization:

```
app/
  decks/
    page.tsx              # ‚úÖ Server Component - calls query helpers
    [id]/
      page.tsx            # ‚úÖ Server Component - calls query helpers
actions/
  deck-actions.ts         # ‚úÖ Server Actions - calls query helpers
  card-actions.ts         # ‚úÖ Server Actions - calls query helpers
db/
  queries/
    decks.ts              # ‚úÖ Database query helpers for decks
    cards.ts              # ‚úÖ Database query helpers for cards
    users.ts              # ‚úÖ Database query helpers for users
  index.ts                # Database client instance
  schema.ts               # Database schema definitions
lib/
  validations.ts          # Zod schemas and types
components/
  create-deck-form.tsx    # Client Component using server actions
  deck-card.tsx           # Client or Server Component (presentational)
```

**Directory Purposes:**
- `app/` - UI pages (Server Components that call query helpers)
- `actions/` - Server Actions that validate input and call query helpers
- `db/queries/` - **ALL database queries** (the only place where `db.select()`, `db.insert()`, etc. appear)
- `lib/` - Validation schemas and shared utilities
- `components/` - Presentational components

## Best Practices

1. **Query abstraction**: ALL database queries must be in `db/queries/` directory - NEVER write queries directly in components or actions

2. **Query helper naming**: Use descriptive names like `getUserDecks`, `createDeck`, `updateDeck`, `deleteDeck`

3. **Always validate**: Every server action must validate input with Zod before processing

4. **Type everything**: Use `z.infer<typeof schema>` to generate TypeScript types from Zod schemas

5. **Return consistent shapes**: Server actions should return `{ success: boolean, data?: T, error?: E }`

6. **Revalidate paths**: After mutations, use `revalidatePath()` to update the UI

7. **Handle errors gracefully**: Use `safeParse()` instead of `parse()` to avoid throwing errors

8. **Co-locate schemas**: Keep Zod schemas near the server actions that use them

9. **Avoid FormData**: Always use typed objects for server action parameters

10. **No client-side mutations**: Database operations only in server components/actions via query helpers

11. **Authentication in queries**: Query helpers should accept `userId` as a parameter

12. **Ownership in queries**: Query helpers should include ownership verification in WHERE clauses

13. **Reusable queries**: Design query helpers to be reusable across multiple actions/components

14. **Document queries**: Add JSDoc comments to query helpers explaining their purpose

## Revalidation Strategies

```typescript
import { revalidatePath, revalidateTag } from 'next/cache';

// Revalidate specific path
revalidatePath('/decks');

// Revalidate dynamic segment
revalidatePath(`/decks/${deckId}`);

// Revalidate all decks pages
revalidatePath('/decks', 'layout');

// Tag-based revalidation (advanced)
// In fetch: fetch(url, { next: { tags: ['decks'] } })
revalidateTag('decks');
```

## Summary

| Operation | Method | UI Layer | Business Logic | Database Layer |
|-----------|--------|----------|----------------|----------------|
| **Read** | Direct call | Server Component | N/A | Query helper in `db/queries/` |
| **Create** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |
| **Update** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |
| **Delete** | Server Action | Client Component | Validate (Zod) + Auth | Query helper in `db/queries/` |

**Remember:**
- üìñ Reads = Server Components ‚Üí Query Helpers
- ‚úèÔ∏è Writes = Server Actions ‚Üí Query Helpers
- üóÑÔ∏è Database = Query Helpers in `db/queries/` ONLY
- ‚úÖ Always = Zod Validation
- üîí Always = Authentication & Authorization
- üö´ Never = FormData types or client-side DB access
- üö´ Never = Direct database queries outside `db/queries/`

**Data Flow:**
```
Component/Action ‚Üí Query Helper ‚Üí Database
     (UI)       ‚Üí (db/queries/)  ‚Üí (Drizzle ORM)
```

## ‚úÖ Pre-Commit Verification Checklist

Before committing ANY code that touches data, verify:

### 1. Database Query Location Check
- [ ] Search your code for `db.select(` - Should ONLY appear in `db/queries/*.ts`
- [ ] Search your code for `db.insert(` - Should ONLY appear in `db/queries/*.ts`
- [ ] Search your code for `db.update(` - Should ONLY appear in `db/queries/*.ts`
- [ ] Search your code for `db.delete(` - Should ONLY appear in `db/queries/*.ts`
- [ ] Search your code for `from(` - Should ONLY appear in `db/queries/*.ts` (Drizzle ORM method)

### 2. Import Verification
- [ ] Components import from `@/db/queries/*` - ‚úÖ CORRECT
- [ ] Server Actions import from `@/db/queries/*` - ‚úÖ CORRECT
- [ ] Components/Actions do NOT import `db` from `@/db` - ‚ùå If they do, it's WRONG
- [ ] Components/Actions do NOT import table schemas (like `decksTable`) - ‚ùå If they do, it's WRONG

### 3. Query Helper Existence
- [ ] Every database operation has a corresponding helper function in `db/queries/`
- [ ] Query helpers are named descriptively (e.g., `getUserDecks`, `createDeck`, `updateDeck`)
- [ ] Query helpers include ownership verification (filter by `userId`)
- [ ] Query helpers have JSDoc comments

### 4. Validation & Security
- [ ] All server actions use Zod validation with `.safeParse()`
- [ ] All server actions check authentication with `await auth()`
- [ ] All server actions return consistent shape: `{ success: boolean, data?: T, error?: E }`
- [ ] All data operations filter by authenticated user's ID

### 5. Architecture Compliance
- [ ] Data fetching happens in Server Components
- [ ] Data mutations happen in Server Actions
- [ ] Client Components only call Server Actions (never database directly)
- [ ] No `useEffect` for data fetching
- [ ] No React Query, SWR, or other client-side data fetching libraries

### 6. File Structure
- [ ] Query helpers are in `db/queries/` directory
- [ ] Server actions are in `actions/` or co-located with routes
- [ ] Zod schemas are in `lib/validations.ts` or co-located with actions
- [ ] No database queries in `app/` directory files

## üõë STOP - If Any Check Fails

If ANY of the above checks fail:

1. **DO NOT COMMIT** - Your code violates the architectural patterns
2. **REFACTOR IMMEDIATELY** - Move database queries to `db/queries/`
3. **CREATE QUERY HELPERS** - Extract all database logic into helper functions
4. **UPDATE IMPORTS** - Change imports to use query helpers instead of direct DB access
5. **RE-RUN CHECKLIST** - Verify all checks pass before committing

## üîç Quick Self-Audit Commands

Run these commands to verify your code follows the patterns:

```bash
# Find any db.select/insert/update/delete outside of db/queries/
# Should return NO results outside of db/queries/ directory
grep -r "db\\.select\\|db\\.insert\\|db\\.update\\|db\\.delete" app/ actions/ components/

# Find any imports of db from @/db outside of db/queries/
# Should return NO results outside of db/queries/ directory  
grep -r "from '@/db'" app/ actions/ components/

# Find any table schema imports outside of db/queries/
# Should return NO results outside of db/queries/ directory
grep -r "from '@/db/schema'" app/ actions/ components/
```

If ANY of these commands return results, **you have architectural violations that MUST be fixed.**

## üìö Final Reminder

**The ONLY place where you should see Drizzle ORM methods (`db.select()`, `db.insert()`, etc.) is in `db/queries/*.ts` files.**

**Everywhere else should ONLY import and call query helper functions.**

**No exceptions. No shortcuts. No "just this once."**

---

## üéØ TL;DR - The Absolute Rules

1. ‚úÖ **ALL database queries** ‚Üí `db/queries/` directory ONLY
2. ‚úÖ **Server Components** ‚Üí Call query helpers from `db/queries/`
3. ‚úÖ **Server Actions** ‚Üí Call query helpers from `db/queries/`
4. ‚ùå **NEVER** write `db.select()`, `db.insert()`, `db.update()`, or `db.delete()` outside `db/queries/`
5. ‚ùå **NEVER** import `db` from `@/db` in components or actions
6. ‚ùå **NEVER** import table schemas in components or actions
7. ‚úÖ **ALWAYS** validate with Zod in server actions
8. ‚úÖ **ALWAYS** authenticate with `await auth()` in server actions
9. ‚úÖ **ALWAYS** filter by `userId` in query helpers

**If you're unsure whether your code follows these rules, IT PROBABLY DOESN'T. Double-check the verification checklist above.**
