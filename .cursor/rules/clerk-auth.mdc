---
alwaysApply: true
---

# Clerk Authentication & Authorization Guidelines

This project uses **Clerk** for all authentication and authorization. Data security is critical: **users must ONLY access their own data**.

## Authentication Setup

- **Auth Provider**: Clerk (@clerk/nextjs)
- **User ID Storage**: `userId` field (varchar 255) in database tables
- **Provider Wrapper**: `components/clerk-provider-wrapper.tsx`
- **Theme Integration**: Clerk UI matches light/dark theme

## Critical Security Rule

ðŸ”’ **USERS CAN ONLY ACCESS THEIR OWN DATA**

Every database query that fetches user-specific data MUST filter by the authenticated user's ID. Failure to do so is a critical security vulnerability.

## Getting the Current User

### Server Components
```typescript
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';

export default async function MyComponent() {
  const { userId } = await auth();
  
  if (!userId) {
    // User is not authenticated - redirect to homepage where sign-in/sign-up buttons are
    redirect('/');
  }
  
  // userId is the Clerk user ID - use it for queries
  const userDecks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
    
  return <div>...</div>;
}
```

### Server Actions
```typescript
'use server';

import { auth } from '@clerk/nextjs/server';
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

export async function createDeck(name: string, description?: string) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId, // Always set the authenticated user's ID
      name,
      description,
    })
    .returning();
    
  return newDeck;
}
```

### API Routes (Route Handlers)
```typescript
import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';

export async function GET() {
  const { userId } = await auth();
  
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
    
  return NextResponse.json(decks);
}
```

### Client Components
```typescript
'use client';

import { useUser } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function MyClientComponent() {
  const { user, isLoaded, isSignedIn } = useUser();
  const router = useRouter();
  
  useEffect(() => {
    if (isLoaded && !isSignedIn) {
      // Redirect to homepage where sign-in/sign-up buttons are
      router.push('/');
    }
  }, [isLoaded, isSignedIn, router]);
  
  if (!isLoaded) {
    return <div>Loading...</div>;
  }
  
  if (!isSignedIn) {
    return null; // Will redirect
  }
  
  // user.id is the Clerk user ID
  // NOTE: Never perform database operations in client components
  // Use Server Actions or API routes instead
  
  return <div>Hello {user.firstName}!</div>;
}
```

## UI Components

Clerk provides pre-built UI components for authentication:

```typescript
import {
  SignInButton,
  SignUpButton,
  SignedIn,
  SignedOut,
  UserButton,
} from '@clerk/nextjs';

// Conditional rendering based on auth state
<SignedOut>
  <SignInButton mode="modal">
    <Button>Sign In</Button>
  </SignInButton>
</SignedOut>

<SignedIn>
  <UserButton afterSignOutUrl="/" />
</SignedIn>
```

## Authorization Patterns

### âœ… CORRECT: Always Filter by User ID

**Creating Records**
```typescript
const [deck] = await db
  .insert(decksTable)
  .values({
    userId, // âœ… Set authenticated user's ID
    name: 'My Deck',
  })
  .returning();
```

**Reading Records**
```typescript
const userDecks = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.userId, userId)); // âœ… Filter by authenticated user
```

**Updating Records**
```typescript
const [updated] = await db
  .update(decksTable)
  .set({ name: 'Updated Name', updatedAt: new Date() })
  .where(
    and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId) // âœ… Ensure user owns the record
    )
  )
  .returning();

if (!updated) {
  throw new Error('Deck not found or unauthorized');
}
```

**Deleting Records**
```typescript
const [deleted] = await db
  .delete(decksTable)
  .where(
    and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId) // âœ… Ensure user owns the record
    )
  )
  .returning();

if (!deleted) {
  throw new Error('Deck not found or unauthorized');
}
```

**Accessing Related Data**
```typescript
// When accessing cards, verify the user owns the parent deck
const cards = await db
  .select()
  .from(cardsTable)
  .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
  .where(
    and(
      eq(cardsTable.deckId, deckId),
      eq(decksTable.userId, userId) // âœ… Verify ownership through join
    )
  );
```

### âŒ FORBIDDEN: Security Vulnerabilities

**Missing User ID Filter**
```typescript
// âŒ CRITICAL SECURITY FLAW - Exposes ALL users' data
const decks = await db.select().from(decksTable);
```

**Using Client-Provided User ID**
```typescript
// âŒ CRITICAL SECURITY FLAW - Client can impersonate any user
export async function createDeck(userId: string, name: string) {
  const [deck] = await db
    .insert(decksTable)
    .values({ userId, name }) // âŒ Never trust client-provided userId
    .returning();
}
```

**Trusting Path/Query Parameters**
```typescript
// âŒ CRITICAL SECURITY FLAW - No ownership verification
export async function deleteDeck(deckId: number) {
  const { userId } = await auth(); // âœ… Get userId from auth
  
  await db
    .delete(decksTable)
    .where(eq(decksTable.id, deckId)); // âŒ Missing userId check!
}
```

**No Authentication Check**
```typescript
// âŒ CRITICAL SECURITY FLAW - No auth verification
export async function getDecks() {
  // Missing: const { userId } = await auth();
  const decks = await db.select().from(decksTable);
  return decks;
}
```

## Route Protection

### Protecting Pages
For pages that require authentication, redirect unauthenticated users to the homepage (where the sign-in/sign-up buttons are located):

```typescript
import { auth } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';

export default async function ProtectedPage() {
  const { userId } = await auth();
  
  if (!userId) {
    // Redirect to homepage where sign-in/sign-up buttons are available
    redirect('/');
  }
  
  // Page content for authenticated users
}
```

### Middleware (Optional)
For app-wide route protection, use Clerk middleware in `middleware.ts`. Configure it to redirect unauthenticated users to the homepage:

```typescript
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';

const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/decks(.*)',
]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) {
    const { userId } = await auth();
    
    if (!userId) {
      // Redirect to homepage where sign-in/sign-up buttons are available
      const homeUrl = new URL('/', req.url);
      return NextResponse.redirect(homeUrl);
    }
  }
});

export const config = {
  matcher: [
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    '/(api|trpc)(.*)',
  ],
};
```

**Note:** This app does not have dedicated sign-in/sign-up pages. All authentication is handled via modal dialogs on the homepage. Protected routes should always redirect to `/` (homepage) when accessed by unauthenticated users.

## Best Practices

1. **Always authenticate first**: Get `userId` from `auth()` before any data operations

2. **Never trust client input**: Always use server-side `auth()` to get the user ID

3. **Filter all queries**: Every user-specific query must include `.where(eq(table.userId, userId))`

4. **Verify ownership**: When updating/deleting, always check the user owns the resource

5. **Use Server Actions**: Prefer Server Actions over API routes for mutations

6. **Handle auth errors**: Always check if `userId` exists and handle unauthenticated cases

7. **Validate relationships**: When accessing related data, verify ownership through joins

8. **Use transactions**: For complex operations, use database transactions to maintain data integrity

9. **Log security events**: Log authentication failures and unauthorized access attempts

10. **Test authorization**: Always test that users cannot access other users' data

## Environment Variables

Required in `.env.local`:
```
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
```

## Error Handling

```typescript
export async function serverAction() {
  try {
    const { userId } = await auth();
    
    if (!userId) {
      return { error: 'Unauthorized', success: false };
    }
    
    // Perform operation
    
    return { success: true, data: result };
  } catch (error) {
    console.error('Server action error:', error);
    return { error: 'Internal server error', success: false };
  }
}
```

## Security Checklist

Before deploying any feature that accesses user data:

- [ ] Authentication check is present (`const { userId } = await auth()`)
- [ ] User ID is verified (`if (!userId)` check exists)
- [ ] All queries filter by authenticated user's ID
- [ ] Update/delete operations verify ownership
- [ ] No client-provided user IDs are trusted
- [ ] Related data access verifies ownership through joins
- [ ] Error messages don't leak sensitive information
- [ ] Server Actions/API routes are not exposed to unauthenticated users

## Additional Resources

- Clerk Next.js Documentation: https://clerk.com/docs/quickstarts/nextjs
- Clerk Server API: https://clerk.com/docs/references/nextjs/overview
- Security Best Practices: https://clerk.com/docs/security/overview
